// -*- C++ -*-
#ifndef Ariadne5_RemnantModel_H
#define Ariadne5_RemnantModel_H
//
// This is the declaration of the RemnantModel class.
//

#include "RemnantModel.fh"
#include "RemnantGluonEmission.h"
#include "ISGtoQEmission.h"
#include "ThePEG/Handlers/HandlerBase.h"
#include "Ariadne/Cascade/Emission.h"
#include "Ariadne/Cascade/RemnantParton.h"
#include "Ariadne/Cascade/QCDDipole.h"
#include "PseudoParton.h"
#include "ThePEG/EventRecord/ParticleTraits.h"
#include "ThePEG/Utilities/SimplePhaseSpace.h"

namespace Ariadne5 {

using namespace ThePEG;

/**
 * RemnantModel is a helper class for emission models dealing with
 * RemnantParton objects. This base class implements the default model
 * for emitting a recoil gluon from a remnant that has received a
 * transverse momentum kick. Furhter more it can emit initial-state
 * type radiation between the hard sub-system and a remnant as well as
 * vetoing or reweighting any other emission from a dipole connected
 * to the remnant.
 *
 * @see \ref RemnantModelInterfaces "The interfaces"
 * defined for RemnantModel.
 */
class RemnantModel: public HandlerBase {

public:

  /** @name Standard constructors and destructors. */
  //@{
  /**
   * The default constructor.
   */
  RemnantModel();

  /**
   * The destructor.
   */
  virtual ~RemnantModel();
  //@}

public:

  /**
   * Return a pseudo-parton to be used in Emitter class for
   * quasi-standard emissions.
   */
  virtual PseudoParton getPseudoParton(tRemParPtr rem) const;

  /**
   * Calculate a weight of an emission is generated from a dipole with
   * remnant \a rem giving a parton with momentum \a pem. \a prem is
   * the momentum of the remnant after the emission. Veto if it is not
   * considered a final-state splitting, otherwise reweight if too
   * much momentum is taken from the remnant. Optionally an \a
   * extracted flavour may be supplied if the emission was an initial
   * state g->q or q->g splitting.
   */
  virtual double reweightFS(tcRemParPtr rem, Energy rho,
			    LorentzMomentum pem, LorentzMomentum prem,
			    tcPDPtr extracted = tcPDPtr()) const;

  /**
   * Return the effective mass of the given remnant to ensure that
   * there is sufficient energy to create relevant hadrons. Optionally
   * supply a new parton to be \a extracted. For hardon remnants this
   * version will return twice the mass of the incoming particle plus
   * the mass of the extracted parton. Otherwise returns zero.
   */
  virtual Energy effectiveMass(tcRemParPtr rem,
			       tcPDPtr extracted = tcPDPtr()) const;

public:

  /**
   * Return the soft suppression weight for an emission at scale \a
   * rho, taking a fraction xplus of the positive momentum of the
   * incoming particle. \a x is the previous extracted momentum
   * fraction.
   */
  double softSuppression(Energy rho, double xplus, double x,
			 Energy mu, double alpha, double spow) const;

  /**
   * If an emission from a remnant dipole results in a remnant with
   * large transverse momentum, return a weight corresponding to the
   * penalty. The arguments are the momentum of the \a hard subsystem,
   * the momentum of the \a remnant with a large transverse momentum,
   * and the pointer to the remnant, \a rem. Optionally an \a
   * extracted flavour may be supplied if the emission was an initial
   * state g->q or q->g splitting. Note that the momenta must be given
   * in the system corresponding to rem->getBoost().
   */
  double
  recoilWeight(const LorentzMomentum & hard, const LorentzMomentum & remnant,
	       tcRemParPtr rem, tcPDPtr extracted = tcPDPtr()) const;

  /**
   * If an emission from a remnant dipole results in a remnat with
   * large transverse momentum, return minimm and maximum allowed
   * positive light-cone momenta for a recoil gluon to be emitted to
   * put the remnant along +z-axis. Arguments are the momentum, \a ph,
   * of the hard sub-system, the momentum \a pr, of the remnant and
   * the effective mass of the remnant, \a effMr.
   */
  pair<Energy,Energy>
  recoilPlusLimit(const LorentzMomentum & ph, const LorentzMomentum & pr,
		  Energy effMr) const;

   /**
   * If the remnant \a rem of the dipole \a dip previously has
   * received a transverse momentum kick, generator the emission of a
   * recoil gluon to get rid of the kick.
   */
  virtual EmPtr
  generateRecoilGluon(const EmitterBase & em,
		      const QCDDipole & dip, tRemParPtr rem,
		      Energy rhomin, Energy rhomax) const;

  /**
   * Perform an emission previously generated by generateRecoilGluon().
   */
  virtual bool performRecoilGluon(const RemnantGluonEmission & e) const;

  /**
   * Revert an emission previously done by performRecoilGluon().
   */
  virtual void revertRecoilGluon(const RemnantGluonEmission & e) const;

   /**
   * If the remnant \a rem of the dipole \a dip previously an
   * extracted heavy quark (with mass above the cutoff) generate a
   * forced emission of that quark with the scale given by tits mass..
   */
  virtual EmPtr
  generateForcedHeavyQuark(const EmitterBase & em,
			   const QCDDipole & dip, tRemParPtr rem,
			   Energy rhomin, Energy rhomax) const;

  /**
   * Perform a ISGtoQEmitter.
   */
  virtual bool performGtoQ(const ISGtoQEmission & e) const;

  /**
   * Revert a ISGtoQEmitter.
   */
  virtual void revertGtoQ(const ISGtoQEmission & e) const;

  /**
   * Set the positive and negative light-cone components of the two
   * given momenta so that their sum is given by \a plus and \a
   * minus. The first momenta is given the largest positive
   * component. The transverse momenta and the masses are left
   * untouched.
   */
  template <typename PType>
  static void setLightCones(PType & p1in, PType & p2in,
			    Energy plus, Energy minus) {
    typedef ParticleTraits<PType> Traits;
    Lorentz5Momentum p1 = Traits::momentum(p1in);
    Lorentz5Momentum p2 = Traits::momentum(p2in);
    Energy2 mt12 = p1.mt2();
    Energy2 mt22 = p2.mt2();
    Energy4 squarg = sqr(plus*minus + mt12 - mt22) - 4.0*mt12*plus*minus;
    if ( squarg < ZERO ) throw ImpossibleKinematics();
    Energy pp1 = 0.5*(sqrt(squarg) + plus*minus + mt12 - mt22)/minus;
    p1 = lightCone5(pp1, mt12/pp1, p1.x(), p1.y());
    Energy pm2 = minus - mt12/pp1;
    p2 = lightCone5(mt22/pm2, pm2, p2.x(), p2.y());
    Traits::set5Momentum(p1in, p1);
    Traits::set5Momentum(p2in, p2);
  }

  /**
   * Return the minimum shat of the new hard subsystem when emitting in
   * the initial state a particle with transverse mass squared, \a mt2, a
   * mass squared, \a mq2, where the original hard subsystem has
   * invariant mass, \a mh2.
   */
  static Energy2 shmin(Energy2 mt2, Energy2 mq2,  Energy2 mh2) {
    return sqr(sqrt(mt2) + sqrt(mt2 - mq2 + mh2));
  }

  /**
   * Return the maximum z of the new hard subsystem when emitting in
   * the initial state a particle with transverse mass squared, \a
   * mt2, a mass squared, \a mq2, where the original hard subsystem
   * has invariant mass, \a mh2, and, optionally, there is a
   * virtuality, \a Q2 on the other side.
   */
  static double zmax(Energy2 mt2, Energy2 mq2, Energy2 mh2, Energy2 Q2 = ZERO) {
    return (mh2 + Q2)/(shmin(mt2, mq2, mh2) + Q2);
  }

  /**
   * Return the maximum rapidity of a particle emitted in the initial
   * state with transverse mass squared, \a mt2, a mass squared, \a
   * mq2, where the original hard subsystem has invariant mass, \a
   * mh2, and the total available invariant mass squared is \a
   * S. Returns a negativ number if kinematically impossible.
   */
  static double ymax(Energy2 mt2, Energy2 mq2, Energy2 mh2, Energy2 S) {
    double arg = (S + mq2 - mh2)/sqrt(mt2*S);
    return arg >= 1.0? acosh(arg/2.0): -1.0;
  }

  /**
   * Return the Jacobian for transforming from the (mass corrected)
   * logarithmic virtuality, |\a k2| + \a mq2, and energy fraction \a
   * z to rapidity and logarithmic transverse mass squared. \a mh2 is
   * the mass squared of the hard sub-system, \a mq2 is the mass of
   * the particle emitten in the initial state, and \a Q2 is the
   * virtuality of the opposing side. The value of this is always
   * below 1/4 + mq2/(mh2 + Q2).
   */
  static double Jk2z(double z, Energy2 mq2, Energy2 mh2, Energy2 Q2 = ZERO) {
    return z*((mh2 + Q2)*(1.0 - z) + mq2*z)/(mh2 + Q2);
  }

  /**
   * Return the Jacobian for transforming from the energy fractions,
   * \a xi and \a z to rapidity and logarithmic transverse mass
   * squared. \a mh2 is the mass squared of the hard sub-system, \a
   * mq2 is the mass of the particle emitten in the initial state, and
   * \a Q2 is the virtuality of the opposing side. The value of this
   * is always below 1/4 + mq2/(mh2 + Q2).
   */
  static double Jxiz(double xi, double z,
		      Energy2 mq2, Energy2 mh2, Energy2 Q2 = ZERO) {
    return (1.0 - xi)*z*((mh2 + Q2)*(1.0 - z) + mq2*z)/(mh2 + Q2);
  }

  /**
   * Calculate the value of xi.
   */
  static double xiFn(Energy2 mt2, double y, Energy2 S) {
    return 1.0 - sqrt(mt2/S)*exp(-y);
  }

  /**
   * Calculate the value of z.
   */
  static double zFn(Energy2 mt2, double xi,
		    Energy2 mq2, Energy2 mh2, Energy2 Q2 = ZERO) {
    return xi*(mh2 + Q2)*(1.0 - xi)/
      (mt2 + (mh2 - mq2)*(1.0 - xi) + Q2*xi*(1.0 - xi));
  }

  /**
   * Return the momenta corresponding to the emission in the initial
   * state from a remnant with momentum \a pr and the hard sub-system
   * with momentum \a ph and invariant mass squared \a mh2. \a kt2 is
   * the squared transverse momentum, \a phi is the azimuth angle and
   * \a mq2 is the mass of the emitted parton. \a xi is the fraction
   * of the sub-system light-cone momenta retained after the
   * emission. \a S is the total invariant mass squared.
   */
  static Triplet<Lorentz5Momentum,Lorentz5Momentum,Lorentz5Momentum>
  getMomenta(Energy2 S, Energy2 kt2, double xi, double phi,
	     Energy2 mq2, Energy2 mh2,
	     const Lorentz5Momentum & pr, const Lorentz5Momentum & ph);

  /**
   * Set momenta of the \a remnant and the hard sub-system according
   * to the given \a emission, where \a qex is extracted from the
   * remnant.
   */
  static void setMom(QCDDipole & d, const ISQEmission & e,
		     tRemParPtr rem, tcPDPtr qex);

  /**
   * Revert what was done by setMom.
   */
  static void revertMom(QCDDipole & d, const ISQEmission & e, tRemParPtr rem);

public:

  /** @name Functions used bythe persistent I/O system. */
  //@{
  /**
   * Function used to write out object persistently.
   * @param os the persistent output stream written to.
   */
  void persistentOutput(PersistentOStream & os) const;

  /**
   * Function used to read in object persistently.
   * @param is the persistent input stream read from.
   * @param version the version number of the object when written.
   */
  void persistentInput(PersistentIStream & is, int version);
  //@}

  /**
   * The standard Init function used to initialize the interfaces.
   * Called exactly once for each class by the class description system
   * before the main function starts or
   * when this class is dynamically loaded.
   */
  static void Init();

protected:

  /** @name Clone Methods. */
  //@{
  /**
   * Make a simple clone of this object.
   * @return a pointer to the new object.
   */
  virtual IBPtr clone() const;

  /** Make a clone of this object, possibly modifying the cloned object
   * to make it sane.
   * @return a pointer to the new object.
   */
  virtual IBPtr fullclone() const;
  //@}

// If needed, insert declarations of virtual function defined in the
// InterfacedBase class here (using ThePEG-interfaced-decl in Emacs).

public:

  /**
   * Indicate that something goes wrong with the recoil gluon.
   */
  struct InconsistentRecoilGluon: public Exception {};

  /**
   * Indicate that something goes wrong with the forced heavy quark emission.
   */
  struct KinematicsException: public Exception {};

  /**
   * Indicate that something goes wrong with the weights in the forced
   * heavy quark emission.
   */
  struct WeightException: public Exception {};

private:

  /**
   * The assignment operator is private and must never be called.
   * In fact, it should not even be implemented.
   */
  RemnantModel & operator=(const RemnantModel &);

};

}

#endif /* Ariadne5_RemnantModel_H */
