// -*- C++ -*-
#ifndef ARIADNE_ExtendedDipole_H
#define ARIADNE_ExtendedDipole_H
//
// This is the declaration of the ExtendedDipole class.
//

#include "Ariadne/DipoleCascade/DipoleState.h"
#include "Ariadne/DipoleCascade/Dipole.h"
#include "Ariadne/DipoleCascade/SoftRemnant.fh"
#include "ExtendedDipole.fh"

namespace Ariadne {

using namespace ThePEG;

/**
 * The ExtendedDipole class represents QCD dipoles between
 * <code>Parton</code>s and is able to perform gluon emissions or
 * initial-state quark emissions according to the Dipole Cascade
 * Model.
 */
class ExtendedDipole: public Dipole {

public:

  /**
   * The DipoleState is a friend.
   */
  friend class DipoleState;

public:

  /** @name Standard constructors and destructors. */
  //@{
  /**
   * The default constructor.
   */
  inline ExtendedDipole();

  /**
   * The copy constructor.
   */
  inline ExtendedDipole(const ExtendedDipole &);

  /**
   * The destructor.
   */
  inline virtual ~ExtendedDipole();
  //@}

public:

  /** @name The main virtual functions to be overridden by sub-classes. */
  //@{
  /**
   * Initialize this dipole. Given then incoming and outgoing partons,
   * \a ip and \a op, set up this dipole. If \a respectScales is true
   * the dipoles will get a maximum scale set by the minimum
   * scale of the original partons.
   */
  virtual void init(tParPtr ip, tParPtr op, bool respectScale = false);

  /**
   * Generate the variables needed to perform an emission. The
   * variables should be saved so that the emission can be performed
   * by a subsequent call to perform().
   *
   * @param pt2min the minimum transverse momentum squared allowed.
   *
   * @param pt2max the minimum transverse momentum squared allowed.
   *
   * @return the transverse momentum squared of the generated
   * emission. If pt2min is returned, no emission was generated.
   */
  virtual Energy2 generate(Energy2 pt2min, Energy2 pt2max);

  /**
   * Perform an emission. Use the information previously generated by
   * generate(Energy2,Energy2) to perform the corresponding emission.
   *
   * @return the parton which is considered to have been emitted, or
   * the null pointer if the emission failed.
   */
  virtual tParPtr perform();
  //@}

protected:

  /**
   * Generate a gluon emission from a dipole between the remnant and the
   * hard sub system. Saves rapidity in genVar.
   *
   * @param pt2min the minimum transverse momentum squared allowed.
   *
   * @param pt2max the minimum transverse momentum squared allowed.
   */
  void genIniG(Energy2 pt2min, Energy2 pt2max);

  /**
   * Perform an emission. Use the information previously generated by
   * genIniG(Energy2,Energy2) to perform the corresponding emission.
   *
   * @return the emitted gluon or null if the emission failed.
   */
  tParPtr performIniG();

  /**
   * Generate a gluon emission from a remnant remnant dipole. Saves
   * rapidity in genVar.
   *
   * @param pt2min the minimum transverse momentum squared allowed.
   *
   * @param pt2max the minimum transverse momentum squared allowed.
   */
  void genRemG(Energy2 pt2min, Energy2 pt2max);

  /**
   * Perform an emission. Use the information previously generated by
   * genRemG(Energy2,Energy2) to perform the corresponding emission.
   *
   * @return the emitted gluon or null if the emission failed.
   */
  tParPtr performRemG();

  /**
   * Creates a new gluon and a new dipole or extended dipole and
   * connects them together.
   */
  virtual ParPtr emitGluon(const Lorentz5Momentum & pg);

  /**
   * Generate a sea quark emission. Saves xi, z and the quark mass in GeV
   * in genVar.
   *
   * @param pt2min the minimum transverse momentum squared allowed.
   *
   * @param pt2max the minimum transverse momentum squared allowed.
   */
  void genSeaQ(Energy2 pt2min, Energy2 pt2max);

  /**
   * Generate a sea quark emission for the specified parton.
   */
  void genSeaQ(tSoftRemPtr par, Energy2 pt2min, Energy2 pt2max);

  /**
   * Perform an emission. Use the information previously generated by
   * genSeaQ(Energy2,Energy2) to perform the corresponding emission.
   *
   * @return the emitted quark or null if the emission failed.
   */
  tParPtr performSeaQ();

  /**
   * Generate an initial state q->gq splitting. Saves z, x and the quark
   * mass in GeV in genVar.
   *
   * @param pt2min the minimum transverse momentum squared allowed.
   *
   * @param pt2max the minimum transverse momentum squared allowed.
   */
  void genQtoGQ(Energy2 pt2min, Energy2 pt2max);

  /**
   * Generate an initial state q->gq splitting for the specified parton
   */
  void genQtoGQ(tSoftRemPtr par, Energy2 pt2min, Energy2 pt2max);

  /**
   * Perform an emission. Use the information previously generated by
   * genSeaQ(Energy2,Energy2) to perform the corresponding emission.
   *
   * @return the emitted quark or null if the emission failed.
   */
  tParPtr performQtoGQ();

  /**
   * Perform an initial state quark emission. This contains the common
   * parts of performSeaQ and performQtoGQ.
   */
  virtual tParPtr performInitialQ();

  /**
   * Generate a gluon emission from a dipole between a hard remnant and
   * a parton. Saves x1 and x3 in genVar.
   *
   * @param pt2min the minimum transverse momentum squared allowed.
   *
   * @param pt2max the minimum transverse momentum squared allowed.
   */
  void genHRemG(Energy2 pt2min, Energy2 pt2max);

  /**
   * Perform an emission. Use the information previously generated by
   * genG(Energy2,Energy2) to perform the corresponding emission.
   *
   * @return the emitted gluon or null if the emission failed.
   */
  tParPtr performHRemG();

public:

  /** @name Simple access functions. */
  //@{
  /**
   * The anti-colour-carrying SoftRemnant in this dipole. May be
   * null.
   */
  inline tSoftRemPtr iSoftRem() const;

  /**
   * The colour-carrying SoftRemnant in this dipole. May be
   * null.
   */
  inline tSoftRemPtr oSoftRem() const;

  /**
   * Set the anti-colour-carrying SoftRemnant in this dipole.
   */
  inline void iSoftRem(tSoftRemPtr);

  /**
   * Set the colour-carrying SoftRemnant in this dipole.
   */
  inline void oSoftRem(tSoftRemPtr);

  /**
   * The anti-colour-carrying HardRemnant in this dipole. May be
   * null.
   */
  inline tHardRemPtr iHardRem() const;

  /**
   * The colour-carrying HardRemnant in this dipole. May be
   * null.
   */
  inline tHardRemPtr oHardRem() const;

  /**
   * Set the anti-colour-carrying HardRemnant in this dipole.
   */
  inline void iHardRem(tHardRemPtr);

  /**
   * Set the colour-carrying HardRemnant in this dipole.
   */
  inline void oHardRem(tHardRemPtr);
  //@}

protected:

  /**
   * Return the ratio of pdfs. The pdf is taken from rem and the
   * nominator is sampled from flavor f1 at x/z and the denominator at x
   * for flavor f2. Returns zero in case of error.
   */
  double PDFRatio(tSoftRemPtr rem, tcPDPtr f1, tcPDPtr f2, Energy2 pt2,
      double x, double z);

  /** 
   * Return the maximum transverse momentum for a given rapidity and
   * soft suppression parameters. Assumes particle 1 has positive
   * rapidity and particles 3 has negative rapidity.
   */
  Energy MaxPT(Energy2 S, double y, Energy mu1, Energy mu3,
      double alpha1, double alpha3);

  /** 
   * Return the maximum transverse momentum for a given rapidity and
   * soft suppression parameters. Assumes soft suppresion only in
   * positive rapidity direction.
   */
  Energy MaxPT(Energy2 S, double y, Energy mu, double alpha);

public:

  /**
   * A class representing the initial-state gluon emission type from a
   * dipole between a remnant and a hard sub-system.
   */
  struct RFGluon: public EmissionType {};

  /**
   * A class representing the initial-state gluon emission type from a
   * dipole between two remnants.
   */
  struct RRGluon: public EmissionType {};

  /**
   * A class representing the initial-state quark emission type from
   * an initial state gluon.
   */
  struct ISGtoQQ: public EmissionType {};

  /**
   * A class representing the initial-state quark emission type from
   * an initial state quark.
   */
  struct ISQtoGQ: public EmissionType {};

  /**
   * A class representing the initial-state gluon emission type from a
   * dipole between a hard remnant and another parton..
   */
  struct HRGluon: public EmissionType {};


protected:

  /**
   * Generate a gluon emission. Saves x1, x3 and rotation angle in
   * genVar.
   *
   * @param pt2min the minimum transverse momentum squared allowed.
   *
   * @param pt2max the minimum transverse momentum squared allowed.
   */
  virtual void genG(Energy2 pt2min, Energy2 pt2max);

  /**
   * Generate a \f$g\rightarrow q\bar{q}\f$ emission. Saves x1, x3 and
   * the quark mass in GeV in genVar.
   *
   * @param pt2min the minimum transverse momentum squared allowed.
   *
   * @param pt2max the minimum transverse momentum squared allowed.
   */
  virtual void genQ(Energy2 pt2min, Energy2 pt2max);

  /**
   * Perform an emission. Use the information previously generated by
   * genG(Energy2,Energy2) to perform the corresponding emission.
   *
   * @return the emitted gluon or null if the emission failed.
   */
  virtual tParPtr performG();

public:

  /** @name Functions used to construct a history.*/
  //@{
  /**
   * Construct the previous state in the cascade associated
   * with the emitter. This will remove one dipole and set
   * the values in the current dipole corresponding to the
   * emission needed to produce the state before
   * the function was called. In the modified dipole set x1, x3,
   * flav, qmass, and pT2.
   * @returns a vector of possible reconstructions associated with
   * the emitter
   */
  virtual DipoleStateVector constructStep();

  /**
   * Returns the emission probability of the emission that was undone
   * in the constructStep method.
   */
  virtual double emissionProbability();

  /**
   * Returns the value of the pdf ratio used in the emission.
   */
  virtual double PDFRatio();
  //@}

protected:

  /** @name Functions used to undo emissions. */
  //@{
  /**
   * Undo a gluon emission with the gluon in OPart and both partons
   * connected to the gluon are remnants.
   */
  bool undoRemOG();

  /**
   * Undo an initial state gluon emission.
   */
  bool undoIniG();

  /**
   * Undo a final state gluon emission.
   */
  bool undoG();

  /**
   * Remove the gluon and one of its neighbouring dipoles.
   */
  bool removeGluon(tParPtr g);

  /**
   * Undo an initial state sea quark emission.
   */
  bool undoSeaQ();

  /**
   * Undo an initial state q->gq emission.
   */
  bool undoQtoGQ(tParPtr);

  /**
   * Undo an initial state quark emission.
   */
  bool undoInitialQ(tSoftRemPtr rem, tParPtr q);
  //@}

  /**
   * Helper function to randomly choose the fraction of an emitter
   * taking part in the emission of a gluon with \a xt and \a y. \a a0
   * is the default value used if a sharp cutoff is used, \a beta is
   * the power suppression and \a R is a random number between 0 and
   * 1. Note that this is not an exact formula but only approximately
   * gives the desired fraction. Note also that this is not used in
   * the emission probability but only in the generation of the
   * recoil gluons.
   */
  static double newa(double xt, double y, double a0, double beta, double R);

protected:

  /** @name Functions relating to the DipoleState to which this belongs. */
  //@{
  /**
   * Return a simple clone of this object. Should be implemented as
   * <code>return new_ptr(*this);</code> by a derived class.
   */
  virtual ClonePtr clone() const;

  /**
   * Fill the provided set with all pointers to CloneBase objects used
   * in this object.
   */
  virtual void fillReferences(CloneSet &) const;

  /**
   * Rebind pointers to other CloneBase objects. Called after a number
   * of interconnected CloneBase objects have been cloned, so that
   * the cloned objects will refer to the cloned copies afterwards.
   *
   * @param trans a TranslationMap relating the original objects to
   * their respective clones.
   */
  virtual void rebind(const TranslationMap & trans);
  //@}

public:

  /** @name Functions used by the persistent I/O system. */
  //@{
  /**
   * Function used to write out object persistently.
   * @param os the persistent output stream written to.
   */
  void persistentOutput(PersistentOStream & os) const;

  /**
   * Function used to read in object persistently.
   * @param is the persistent input stream read from.
   * @param version the version number of the object when written.
   */
  void persistentInput(PersistentIStream & is, int version);
  //@}

  /**
   * The standard Init function used to initialize the interfaces.
   * Called exactly once for each class by the class description system
   * before the main function starts or
   * when this class is dynamically loaded.
   */
  static void Init();

private:

  /**
   * The anti-colour-carrying SoftRemnant in this dipole. May be
   * null.
   */
  tSoftRemPtr theISoftRem;

  /**
   * The colour-carrying SoftRemnant in this dipole. May be
   * null.
   */
  tSoftRemPtr theOSoftRem;

  /**
   * The anti-colour-carrying HardRemnant in this dipole. May be
   * null.
   */
  tHardRemPtr theIHardRem;

  /**
   * The colour-carrying HardRemnant in this dipole. May be
   * null.
   */
  tHardRemPtr theOHardRem;

public:

  /**
   * Print out debugging information on std::cerr.
   */
  virtual void debugme() const;

  /**
   * Check integrety of the emitter. Return false if error is found.
   */
  virtual bool checkIntegrety();

private:

  /**
   * The static object used to initialize the description of this class.
   * Indicates that this is a concrete class with persistent data.
   */
  static ClassDescription<ExtendedDipole> initExtendedDipole;

  /**
   * The assignment operator is private and must never be called.
   * In fact, it should not even be implemented.
   */
  ExtendedDipole & operator=(const ExtendedDipole &);

};

}

#include "ThePEG/Utilities/ClassTraits.h"

namespace ThePEG {

/** @cond TRAITSPECIALIZATIONS */

/** This template specialization informs ThePEG about the
 *  base classes of ExtendedDipole. */
template <>
struct BaseClassTrait<Ariadne::ExtendedDipole,1> {
  /** Typedef of the first base class of ExtendedDipole. */
  typedef Ariadne::Dipole NthBase;
};

/** This template specialization informs ThePEG about the name of
 *  the ExtendedDipole class and the shared object where it is defined. */
template <>
struct ClassTraits<Ariadne::ExtendedDipole>
  : public ClassTraitsBase<Ariadne::ExtendedDipole> {
  /** Return a platform-independent class name */
  static string className() { return "Ariadne::ExtendedDipole"; }
  /** Return the name of the shared library be loaded to get
   *  access to the ExtendedDipole class and every other class it uses
   *  (except the base class). */
  static string library() { return "libArCascade.so"; }
};

/** @endcond */

}

#include "ExtendedDipole.icc"
#ifndef ThePEG_TEMPLATES_IN_CC_FILE
// #include "ExtendedDipole.tcc"
#endif

#endif /* ARIADNE_ExtendedDipole_H */
