// -*- C++ -*-
#ifndef ARIADNE_Emitter_H
#define ARIADNE_Emitter_H
//
// This is the declaration of the Emitter class.
//

#include "CascadeBase.h"
#include "Emitter.fh"
#include "Parton.fh"
#include "MECorrBase.fh"

namespace Ariadne {

using namespace ThePEG;

/**
 * Emitter is the base class of all classes able to perform parton
 * emissions according to the Dipole Cascade Model and its extensions.
 */
class Emitter: public CascadeBase {

public:

  /**
   * A vector of dipolstates
   */
  typedef vector<DipoleStatePtr> DipoleStateVector;

public:

  /**
   * The DipoleState is a friend.
   */
  friend class DipoleState;

public:

  /** @name Standard constructors and destructors. */
  //@{
  /**
   * The default constructor.
   */
  inline Emitter();

  /**
   * The copy constructor.
   */
  inline Emitter(const Emitter &);

  /**
   * The destructor.
   */
  inline virtual ~Emitter();
  //@}

public:

  /** @name The main virtual functions to be overridden by sub-classes. */
  //@{
  /**
   * Generate the variables needed to perform an emission. The
   * variables should be saved so that the emission can be performed
   * by a subsequent call to perform().
   *
   * @param pt2min the minimum transverse momentum squared allowed.
   *
   * @param pt2max the minimum transverse momentum squared allowed.
   *
   * @return the transverse momentum squared of the generated
   * emission. If 0 is returned, no emission was generated.
   */
  virtual Energy2 generate(Energy2 pt2min, Energy2 pt2max) = 0;

  /**
   * Perform an emission. Use the information previously generated by
   * generate(Energy2,Energy2) to perform the corresponding emission.
   *
   * @return the parton which is considered to have been emitted, or
   * the null pointer if the emission failed.
   */
  virtual tParPtr perform() = 0;

  /**
   * Setup internal constants and prepare to be able to generate. \a
   * pt2max is the maximum possible squared transverse momentum
   * possible for this emitter.
   */
  virtual void setup(Energy2 pt2max);
  //@}

  /**
   * Call perform and return true if the emission succeded and was not
   * vetoed by any reweighting.
   */
  bool performEmission();

public:

  /**
   * Generate an squared invariant transverse momentum. The
   * distribution used is \f$C\alpha_S\frac{dp_\perp^2}{p_\perp^2}\f$
   * multiplied with the corresponding Sudakov formfactor. The maximum
   * \f$p_\perp^2\f$ is \a pt2max and \a C is the constant. This
   * automatically takes care of whether we are using a running
   * \f$\alpha_S\f$ or whatever.
   */
  Energy2 rndsud(double C, Energy2 pt2max, Energy2 pt2min) const;

  /**
   * Generate an squared invariant transverse momentum. The
   * distribution used is \f$C\alpha_{EM}\frac{dp_\perp^2}{p_\perp^2}\f$
   * multiplied with the corresponding Sudakov formfactor. The maximum
   * \f$p_\perp^2\f$ is \a pt2max and \a C is the constant. This
   * automatically takes care of whether we are using a running
   * \f$\alpha_{EM}\f$ or whatever.
   */
  Energy2 rndsudEM(double C, Energy2 pt2max, Energy2 pt2min) const;

  /**
   * Check if the given 3-parton kinematical configuration is
   * kinematically possible.
   *
   * @param x1 the energy fraction of parton 1 (times two).
   * @param x3 the energy fraction of parton 3 (times two).
   * @param y1 the squared mass fraction of parton 1.
   * @param y2 the squared mass fraction of parton 2.
   * @param y3 the squared mass fraction of parton 3.
   *
   * @rturn true if kinematically possible.
   */
  bool check(double x1, double x3, double y1, double y2, double y3) const;

public:

  /** @name Simple access functions. */
  //@{
  /**
   * The scale of the last generated emission.
   */
  inline Energy2 lastPT2() const;

  /**
   * The constant \f$\alpha_S\f$ or the constant to be divided by the
   * log of the scale.
   */
  inline double alpha0() const;

  /**
   * The \f$\lambda{QCD}^2\f$ used in the running \f$\alpha_S\f$. If
   * negative, a fixed coupling is used.
   */
  inline Energy2 lambdaQCD2() const;

  /**
   * Set the scale of the last generated emission.
   */
  inline void lastPT2(Energy2);

  /**
   * A MECorrBase object for leading-order matrix-element correction.
   * @return null if no MECorrBase is present.
   */
  inline tcMECPtr MECorr() const;

  /**
   * Remove the matrix-element correction after it has been used once.
   */
  inline void removeMECorr();

  /**
   * The maximum scale allowed for an emission in this Emitter.
   */
  inline Energy2 maxScale() const;

  /**
   * The maximum scale allowed for an emission in this Emitter.
   */
  inline void maxScale(Energy2);
  //@}

public:

  /** @name Functions used to construct a history.*/
  //@{
  /**
   * Construct the previous state in the cascade associated
   * with the emitter. This will remove one dipole and set
   * the values in the current dipole corresponding to the
   * emission needed to produce the state before
   * the function was called.
   * @returns a vector of possible reconstructions associated with
   * the emitter
   */
  inline virtual DipoleStateVector constructStep();

  /**
   * Returns the emission probability of the emission that was undone
   * in the constructStep method.
   */
  inline virtual double emissionProbability();

  /**
   * Returns the value of the coupling constant at the scale of the undone
   * emission.
   */
  inline virtual double coupling();

  /**
   * Returns the value of the pdf ratio used in the emission.
   */
  inline virtual double PDFRatio();
  //@}

public:

  /**
   * This is a base class defining which kind of emission is under
   * consideration. Concrete classes inheriting from Emitter should
   * define one such class for each kind of emission which is
   * possible.
   */
  struct EmissionType {
    /** A virtual destructor is needed to get the type id system to work. */
    virtual ~EmissionType() {}
  };

  /**
   * Check if the given EmissionType is of a specified kind.
   */
  template <typename Type>
  static bool isType(const EmissionType & et) {
    return dynamic_cast<const Type *>(&et);
  }

  /**
   * Check if the last generated EmissionType is of a specified kind.
   */
  template <typename Type>
  bool isType(const Type &) const {
    return dynamic_cast<const Type *>(theEType);
  }

  /**
   * Set the last emission type.
   */
  template <typename Type>
  void lastEType(const Type &) {
    if ( theEType ) delete theEType;
    theEType = new Type();
  }

  /**
   * Get the last emission type.
   */
  const EmissionType * lastEType() const {
    return theEType;
  }

  /** @name Functions for external reweighting of emissions. */
  //@{
  /**
   * Return a factor to multiply the basic emission probability
   * for an emission of a parton with PDG number \a id from the given
   * \a dipole to ensure that a subsequent call to reweight() will
   * give a number less than unity. Besides the \a id, an emission \a
   * type need to be specified.
   */
  double preweight(tcEmiPtr dipole, tcDipoleStatePtr state, long id,
		   const EmissionType & type) const;
  
  /**
   * Return reweighting of an emission of a parton with PDG number \a
   * id and mass emass from the given dipole, \a dip. The transverse
   * momentum squared, \a pt2, and the vector of doubles that will be
   * stored in genVar must be given. Besides the \a id, an emission \a
   * type need to be specified.
   * 
   */
  double reweight(tcEmiPtr dip, tcDipoleStatePtr state, long id,
		  Energy2 pt2, vector<double> & genVar,
		  const EmissionType & type) const;

  /**
   * In addition to the reweight function a final hit/miss veto may be
   * given after the emission has been performed. The arguments are
   * the original \a dipole, the final dipole \a state and the emitted
   * \a parton. Also the scale (\a pt2) and \a type of the emission
   * must be supplied.
   */
  bool finalVeto(tcEmiPtr dipole, tcDipoleStatePtr state, ParPtr parton,
		 Energy2 pt2, const EmissionType & type) const;
  //@}

protected:

  /** @name Functions relating to the DipoleState to which this belongs. */
  //@{
  /**
   * Fill the provided set with all pointers to CloneBase objects used
   * in this object.
   */
  inline virtual void fillReferences(CloneSet &) const;

  /**
   * Rebind pointers to other CloneBase objects. Called after a number
   * of interconnected CloneBase objects have been cloned, so that
   * the cloned objects will refer to the cloned copies afterwards.
   *
   * @param trans a TranslationMap relating the original objects to
   * their respective clones.
   */
  inline virtual void rebind(const TranslationMap & trans);
  //@}

public:

  /** @name Functions used by the persistent I/O system. */
  //@{
  /**
   * Function used to write out object persistently.
   * @param os the persistent output stream written to.
   */
  void persistentOutput(PersistentOStream & os) const;

  /**
   * Function used to read in object persistently.
   * @param is the persistent input stream read from.
   * @param version the version number of the object when written.
   */
  void persistentInput(PersistentIStream & is, int version);
  //@}

  /**
   * The standard Init function used to initialize the interfaces.
   * Called exactly once for each class by the class description system
   * before the main function starts or
   * when this class is dynamically loaded.
   */
  static void Init();

protected:

  /**
   * Exception class used if weights larger that one is encountered.
   */
  struct WeightException: Exception {};

private:

  /**
   * The scale of the last generated emission.
   */
  Energy2 theLastPT2;

  /**
   * The type of the last generated emission.
   */
  const EmissionType * theEType;

  /**
   * The constant \f$\alpha_S\f$ or the constant to be divided by the
   * log of the scale.
   */
  double theAlpha0;

  /**
   * The \f$\lambda{QCD}^2\f$ used in the running \f$\alpha_S\f$. If
   * negative, a fixed coupling is used.
   */
  Energy2 theLambdaQCD2;

  /**
   * A MECorrBase object for leading-order matrix-element correction.
   */
  tcMECPtr theMECorr;

  /**
   * The maximum scale allowed for an emission in this Emitter.
   */
  Energy2 theMaxScale;

protected:
  /**
   * Vector used to store data when generating emissions.
   */
  vector<double> genVar;

public:

  /**
   * Print out debugging information on std::cerr.
   */
  virtual void debugme() const;

  /**
   * Check integrety of the emitter. Return false if error is found.
   */
  virtual bool checkIntegrety();

private:

  /**
   * The static object used to initialize the description of this class.
   * Indicates that this is an abstract class with persistent data.
   */
  static AbstractClassDescription<Emitter> initEmitter;

  /**
   * The assignment operator is private and must never be called.
   * In fact, it should not even be implemented.
   */
  Emitter & operator=(const Emitter &);

};

}

#include "ThePEG/Utilities/ClassTraits.h"

namespace ThePEG {

/** @cond TRAITSPECIALIZATIONS */

/** This template specialization informs ThePEG about the
 *  base classes of Emitter. */
template <>
struct BaseClassTrait<Ariadne::Emitter,1> {
  /** Typedef of the first base class of Emitter. */
  typedef Ariadne::CascadeBase NthBase;
};

/** This template specialization informs ThePEG about the name of
 *  the Emitter class and the shared object where it is defined. */
template <>
struct ClassTraits<Ariadne::Emitter>
  : public ClassTraitsBase<Ariadne::Emitter> {
  /** Return a platform-independent class name */
  static string className() { return "Ariadne::Emitter"; }
  /** Return the name of the shared library be loaded to get
   *  access to the Emitter class and every other class it uses
   *  (except the base class). */
  static string library() { return "libArCascade.so"; }
};

/** @endcond */

}

#include "DipoleState.h"
#include "Emitter.icc"
#ifndef ThePEG_TEMPLATES_IN_CC_FILE
// #include "Emitter.tcc"
#endif

#endif /* ARIADNE_Emitter_H */
