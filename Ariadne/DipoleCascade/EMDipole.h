// -*- C++ -*-
#ifndef ARIADNE_EMDipole_H
#define ARIADNE_EMDipole_H
//
// This is the declaration of the EMDipole class.
//

#include "Ariadne/DipoleCascade/Emitter.h"
#include "EMDipole.fh"
#include "Parton.fh"

namespace Ariadne {

using namespace ThePEG;

/**
 * The EMDipole class represents electromagnetic dipoles between partons
 * and is able to perform photon emissions.
 */
class EMDipole: public Emitter {

public:

  /** @name Standard constructors and destructors. */
  //@{
  /**
   * The default constructor.
   */
  inline EMDipole();

  /**
   * The copy constructor.
   */
  inline EMDipole(const EMDipole &);

  /**
   * The destructor.
   */
  virtual ~EMDipole();
  //@}

  /** @name The main virtual functions to be overridden by sub-classes. */
  //@{
  /**
   * Initialize this dipole. Given then incoming and outgoing partons,
   * \a ip and \a op, set up this dipole. If \a respectScales is true
   * the dipoles will get a maximum scale set by the minimum
   * scale of the original partons.
   *
   * @return truf if initialization succeded.
   */
  virtual bool init(tParPtr ip, tParPtr op, bool respectScale = false);

  /**
   * Generate the variables needed to perform an emission. Saves x1 and
   * x3 in genVar. The variables should be saved so that the emission
   * can be performed by a subsequent call to perform().
   *
   * @param pt2min the minimum transverse momentum squared allowed.
   *
   * @param pt2max the minimum transverse momentum squared allowed.
   *
   * @return the transverse momentum squared of the generated
   * emission. If pt2min is returned, no emission was generated.
   */
  virtual Energy2 generate(Energy2 pt2min, Energy2 pt2max);

  /**
   * Perform an emission. Use the information previously generated by
   * generate(Energy2,Energy2) to perform the corresponding emission.
   *
   * @return the emitted photon or null if the emission failed.
   */
  virtual tParPtr perform();
  //@}
  
protected:

  /** @name Functions relating to the DipoleState to which this belongs. */
  //@{
  /**
   * Return a simple clone of this object. Should be implemented as
   * <code>return new_ptr(*this);</code> by a derived class.
   */
  virtual ClonePtr clone() const;

  /**
   * Fill the provided set with all pointers to CloneBase objects used
   * in this object.
   */
  virtual void fillReferences(CloneSet &) const;

  /**
   * Rebind pointer to other CloneBase objects. Called after a number
   * of interconnected CloneBase objects have been cloned, so that
   * the cloned objects will refer to the cloned copies afterwards.
   *
   * @param trans a TranslationMap relating the original objects to
   * their respective clones.
   */
  virtual void rebind(const TranslationMap & trans);
  //@}

public:

  /** @name Functions used by the persistent I/O system. */
  //@{
  /**
   * Function used to write out object persistently.
   * @param os the persistent output stream written to.
   */
  void persistentOutput(PersistentOStream & os) const;

  /**
   * Function used to read in object persistently.
   * @param is the persistent input stream read from.
   * @param version the version number of the object when written.
   */
  void persistentInput(PersistentIStream & is, int version);
  //@}

  /**
   * The standard Init function used to initialize the interfaces.
   * Called exactly once for each class by the class description system
   * before the main function starts or
   * when this class is dynamically loaded.
   */
  static void Init();

public:

  /** @name Simple access functions. */
  //@{
  /**
   * The first parton in this dipole.
   */
  inline tParPtr iPart() const;

  /**
   * The second parton in this dipole.
   */
  inline tParPtr oPart() const;

  /**
   * Set the first parton in this dipole.
   */
  inline void iPart(tParPtr);

  /**
   * Set the second parton in this dipole.
   */
  inline void oPart(tParPtr);

  /**
   * Return the squared invariant mass of this dipole.
   */
  Energy2 sdip() const;

  //@}

public:

  /** A class representing photon emission from an EMDipole. */
  struct EMPhoton: public EmissionType {};

private:

  /**
   * The first parton in this dipole.
   */
  tParPtr theIPart;

  /**
   * The second parton in this dipole.
   */
  tParPtr theOPart;

public:

  /**
   * Print out debugging information on std::cerr.
   */
  virtual void debugme() const;

private:

  /**
   * The static object used to initialize the description of this class.
   * Indicates that this is a concrete class with persistent data.
   */
  static ClassDescription<EMDipole> initEMDipole;

  /**
   * The assignment operator is private and must never be called.
   * In fact, it should not even be implemented.
   */
  EMDipole & operator=(const EMDipole &);

};

}

#include "ThePEG/Utilities/ClassTraits.h"

namespace ThePEG {

/** @cond TRAITSPECIALIZATIONS */

/** This template specialization informs ThePEG about the
 *  base classes of EMDipole. */
template <>
struct BaseClassTrait<Ariadne::EMDipole,1> {
  /** Typedef of the first base class of EMDipole. */
  typedef Ariadne::Emitter NthBase;
};

/** This template specialization informs ThePEG about the name of
 *  the EMDipole class and the shared object where it is defined. */
template <>
struct ClassTraits<Ariadne::EMDipole>
  : public ClassTraitsBase<Ariadne::EMDipole> {
  /** Return a platform-independent class name */
  static string className() { return "Ariadne::EMDipole"; }
  /**
   * The name of a file containing the dynamic library where the class
   * EMDipole is implemented. It may also include several, space-separated,
   * libraries if the class EMDipole depends on other classes (base classes
   * excepted). In this case the listed libraries will be dynamically
   * linked in the order they are specified.
   */
  static string library() { return "libArCascade.so"; }
};

/** @endcond */

}

#include "EMDipole.icc"
#ifndef ThePEG_TEMPLATES_IN_CC_FILE
// #include "EMDipole.tcc"
#endif

#endif /* ARIADNE_EMDipole_H */
