#!@PERL@ -w
# @configure_input@
#

use strict;

sub getattr($$);
sub checkspace($);

my @files;
my @variables;
my @pinput;
my @poutput;
my @init;
my @interfaces;
my $tags = "aidx|flag|parm|h3|modeopen|modepick|parmfix";

my $version = -1.0;

my $dovar = 0;
my $doinp = 0;
my $doout = 0;
my $doini = 0;
my $doint = 0;

if ( $ARGV[0] eq "--var" ) {
    $dovar = 1;
    shift @ARGV;
}
elsif ( $ARGV[0] eq "--input" ) {
    $doinp = 1;
    shift @ARGV;
}
elsif ( $ARGV[0] eq "--output" ) {
    $doout = 1;
    shift @ARGV;
}
elsif ( $ARGV[0] eq "--init" ) {
    $doini = 1;
    shift @ARGV;
}
elsif ( $ARGV[0] eq "--interfaces" ) {
    $doint = 1;
    shift @ARGV;
}
else {
    $dovar = 1;
    $doinp = 1;
    $doout = 1;
    $doini = 1;
    $doint = 1;
}

my $class = shift @ARGV;
my $dir = "";
if ( $class =~ /(.*\/)([^\/]+)$/ ) {
    $class = $2;
    $dir = $1;
}

push @files, "@PYTHIA8_DIR@/xmldoc/Index.xml";

while ( @files ) {
#    print "Opening $files[0]\n";
    open(FILE,"<$files[0]") || die "Cannot find Pythia XML file: $files[0]";
    my @lines = (<FILE>);
    close(FILE);
    shift @files;
    chomp(@lines);
    my $file = "@lines";

    while ( $file =~ /<($tags\b)(.*?)>(.*?)(<\/\1>|(?=(<($tags))))/g ) {
	my $tag = $1;
	my $attr = $2;
	my $content = $3;
	$content =~ s/<aloc\s+href="(.*?)"\s*>here<\/aloc>/in the '$1' section of the online Pythia8 manual/g;
	$content =~ s/<aloc\s+href="(.*?)"\s*>(.*?)<\/aloc>/$2 (see '$1' section of the online Pythia8 manual)/g;
	$content =~ s/"/\\"/g;
	$content =~ s/<\/?ei>/\\\\f\$/g;
	if ( $tag eq "aidx" ) {
	    my $name = getattr($attr, "href");
	    push @files, "@PYTHIA8_DIR@/xmldoc/$name.xml";
	    next;
	}
	my $name = getattr($attr, "name");
	if ($tag eq "parmfix" ) {
	    if ( $name eq "Pythia:versionNumber" ) {
		$version = getattr($attr, "default");
		next;
	    }
	}

	next if !$name || !checkspace($name);
#	print "Found $tag $name\n";
	my $def = getattr($attr, "default");
	if ( $tag eq "flag" ) {
	    $def = "true" if $def eq "on";
	    $def = "false" if $def eq "off";
	    $name =~ tr/:/_/;
	    push @variables, "  /** Auto-generated interface variable. */\n",
	    "  bool the$name;\n\n";
	    push @pinput, "    >> the$name\n";
	    push @poutput, "    << the$name\n";
	    push @init, "    the$name($def),\n";
	    push @interfaces, <<THEEND
  static Switch<$class,bool> interface$name
    ("$name",
     "$content",
     &${class}::the$name, $def, true, false);
  static SwitchOption interface${name}On
    (interface$name,
     "On",
     "On",
     true);
  static SwitchOption interface${name}Off
    (interface$name,
     "Off",
     "Off",
     false);

THEEND
;    
	}
	elsif ( $tag eq "parm" ) {
	    my $min = getattr($attr, "min");
	    my $max = getattr($attr, "max");
	    my $lim = "Interface::limited";
	    if ( !$max && !$min ) {
		$lim = "Interface::nolimits";
		$max = "0.0";
		$min = "0.0";
	    } elsif ( !$min ) {
		$lim = "Interface::upperlim";
		$min = "0.0";
	    } elsif ( !$max ) {
		$lim = "Interface::lowerlim";
		$max = "0.0";
	    }
	    $name =~ tr/:/_/;
	    push @variables, "  /** Auto-generated interface variable. */\n",
	    "  double the$name;\n\n";
	    push @pinput, "    >> the$name\n";
	    push @poutput, "    << the$name\n";
	    push @init, "    the$name($def),\n";
	    push @interfaces, <<THEEND
  static Parameter<$class,double> interface$name
    ("$name",
     "$content",
     &${class}::the$name, $def, $min, $max,
     true, false, $lim);

THEEND
;    
	}
	elsif ( $tag eq "modepick" ) {
	    my $desc = $content;
	    if ( $content =~ /^(.*?)<option.*<\/option>(.*?$)/ ) {
		$desc = "$1$2";
	    }
	    $name =~ tr/:/_/;
	    push @variables, "  /** Auto-generated interface variable. */\n",
	    "  int the$name;\n\n";
	    push @pinput, "    >> the$name\n";
	    push @poutput, "    << the$name\n";
	    push @init, "    the$name($def),\n";
	    push @interfaces, <<THEEND
  static Switch<$class,int> interface$name
    ("$name",
     "$desc",
     &${class}::the$name, $def, true, false);

THEEND
;    
	    while ( $content =~
		    /<option\s+value=\\"(\w+)\\"\s*>(.*?)<\/option>/g ) {
		my $opti = $1;
		my $opt = $1;
		$opt =~ s/-/_/g;
		my $desc = $2;
		push @interfaces, <<THEEND
  static SwitchOption interface${name}$opt
    (interface$name,
     "$opt",
     "$desc",
     $opti);

THEEND
;    
	    }
	}
	elsif ( $tag eq "modeopen" or $tag eq "mode" ) {
	    my $min = getattr($attr, "min");
	    my $max = getattr($attr, "max");
	    my $lim = "Interface::limited";
	    if ( !$max && !$min ) {
		$lim = "Interface::nolimits";
		$max = "0.0";
		$min = "0.0";
	    } elsif ( !$min ) {
		$lim = "Interface::upperlim";
		$min = "0.0";
	    } elsif ( !$max ) {
		$lim = "Interface::lowerlim";
		$max = "0.0";
	    }
	    $name =~ tr/:/_/;
	    push @variables, "  /** Auto-generated interface variable. */\n",
	    "  int the$name;\n\n";
	    push @pinput, "    >> the$name\n";
	    push @poutput, "    << the$name\n";
	    push @init, "    the$name($def),\n";
	    push @interfaces, <<THEEND
  static Parameter<$class,int> interface$name
    ("$name",
     "$content",
     &${class}::the$name, $def, $min, $max,
     true, false, $lim);

THEEND
;    
	}
    }
}

push @variables, "  /** Auto-generated interface variable. */\n",
	    "  vector<string> theAdditionalP8Settings;\n\n";
if ( $dovar ) {
    open(OUT,">$dir$class-var.h");
    print OUT @variables;
    close(OUT);
}

if ( $doini ) {
    push @init, "    theAdditionalP8Settings()\n";
    open(OUT,">$dir$class-init.h");
    print OUT @init;
    close(OUT);
}

if ( $doinp ) {
    push @pinput, "    >> theAdditionalP8Settings\n";
    open(OUT,">$dir$class-input.h");
    print OUT @pinput;
    close(OUT);
}

if ( $doout ) {
    push @poutput, "    << theAdditionalP8Settings\n";
    open(OUT,">$dir$class-output.h");
    print OUT @poutput;
    close(OUT);
}

push @interfaces, <<THEEND
  static ParVector<$class,string> interfaceAdditionalP8Settings
    ("AdditionalP8Settings",
     "Each string in this vector will be sent to the Pythia8 Settings "
     "object using the Pythia::readString function. Note that most relevant "
     "settings are already available as normal ThePEG interfaces, and that "
     "this interface should be used with care.",
     &${class}::theAdditionalP8Settings, -1, "", "", "",
     true, false, Interface::nolimits);

THEEND
;

if ( $doint ) {
    open(OUT,">$dir$class-interfaces.h");

    if ( $class eq "StringFragmentation" ) {
	print OUT <<THEEND
  static ClassDocumentation<StringFragmentation> documentation
    ("The StringFragmentation class is a straight interface to the Lund "
     "string fragmentation routines in Pythia 8.",
     "Hadronization performed according to the "
     "Lund String Fragmentation scheme \\\\cite{And83} as implemented in "
     "Pythia\\\\cite{Sjostrand:2007gs,Sjostrand:2006za} version $version.",
     "\\\\bibitem{And83} B.~Andersson, G.~Gustafson, "
     "G.~Ingelman and T.~Sj\\\\\\\"ostrand"
     "\\n Phys.~Rep.~{\\\\bf 97} (1983) 31.\\n"
     "\\\\bibitem{Sjostrand:2007gs} T.~Sj\\\\\\\"ostrand, S.~Mrenna, P.~Skands, "
     "Comput.~Phys.~Commun.\\\\ {\\\\bf 178} (2008) 852.\\n"
     "\\\\bibitem{Sjostrand:2006za} T.~Sj\\\\\\\"ostrand, S.~Mrenna, P.~Skands, "
     "JHEP06~(2006)~026.");

THEEND
;
    }



    print OUT @interfaces;
    close(OUT);
}

sub getattr($$) {
  my $string = $_[0];
  my $tag = $_[1];
  my $ret;
  if ( $string =~ /$tag\s*=\s*"(.*?)"/ ) {
    $ret = $1;
  }
  return $ret;
}

sub checkspace($) {
    foreach my $arg ( @ARGV ) {
	return 1 if $_[0] =~ /^$arg:/;
    }
    return 0;
}
